[{"title":"Django简单接口开发","date":"2020-01-12T07:14:14.106Z","path":"2020/01/12/Django简单接口开发/","text":"Django简单接口开发 123注意：本文数据库及数据未展示说明：有些模块是需要导入的，可以使用alt加回车键选择导入（部分代码导入可能有遗漏）最后更新时间：2020-1-13 1.什么是DjangoDjango是一个由Python写成的开放源代码的Web应用框架，采用了MTV的框架模式，它最初是被开发来用于管理劳伦斯出版集团旗下的一些以新闻内容为主的网站的，即是CMS（内容管理系统）软件。并于2005年7月在BSD许可证下发布。 2.如何创建一个Django项目这篇文章详细描述了如何创建一个Django项目: 超详细创建Django项目并存在Gitee仓库中。 3.目录文件详解 3.1 与项目名同名的文件夹 apidemo ​ a. settings.py是放置全局配置，自动生成的 ​ b. urls.py是主要的url入口，自动生成的 ​ c. wsgi.py是服务器网关接口，自动生成的 3.2 文件夹common是我们创建应用时产生的文件夹 ​ a. migrations是数据移植（迁移）模块，一般情况下我们不动这个模块，自动生成的 ​ b. admin.py是Django自带的后台管理的配置文件，自动生成的。可以设置账号，也可以在Terminal中输入 python manage.py createsuperuser，然后根据提示输入用户名和密码 ​ c. apps.py是该应用的一些配置 1.9以后自动生成 ​ d. models.py是数据模块，写与数据库相关的类，自动生成的 ​ e. serializers.py是写序列化器的模块，手动添加的，具体使用请看后续 ​ f. tests.py是自动化测试模块 ，在这里编写测试脚本，自动生成的 ​ g. urls.py是该应用的url入口，手动添加的，具体使用请看后续 ​ h. utils.py是工具模块，手动添加的 ​ i. views.py是执行响应的代码所在模块 代码逻辑处理主要地点 项目大部分代码在此编写，自动生成的 3.3 文件夹static是手动添加的存放静态文件的(如html，css，js等) ​ html下的test是手动添加的一个html文件，具体使用请看后续 3.4 文件夹vene是虚拟环境文件夹，存放一些依赖项 3.5 .gitignore是忽略文件，用于忽略一些不提交到仓库的文件 3.6 manage.py是启动django的主要文件 3.7 requirements.txt是存放依赖项目录的文件，方便下载依赖项 4.模型创建有两种方式 a. 当数据库存在，但未创建表时 ​ 写好数据模型 ​ ​ 生成迁移 python manage.py makemigrations polls ​ ​ 迁移 python manage.py migrate​ b. 当数据库存在，且表和数据都已创建好的时候， ​ 反向工程,把表变工程,(将结果输出重定向到models.py的文件中) ​ python manage.py inspectdb &gt; common/models.py ​ 5.视图函数我们要用到一些第三方库，请先使用pip安装这些库 123django-filter==2.2.0djangorestframework==3.11.0mysqlclient==1.4.6 接口有多种写法，这里举个例子 省会城市的接口 123456789101112131415# 导入模块from rest_framework.decorators import api_viewfrom common.models import Districtfrom common.serializers import DistrictSimpleSerializerfrom rest_framework.response import Response@api_view(('GET',)) # 指定方式（概念中的将动词放到HTTP协议中）def get_provinces(request): # 取数据为null的数据，.only表示只取字段为xx的数据 queryset = District.objects.filter(pid__isnull=True).only('distid', 'name') # 用序列化器进行序列 serializer = DistrictSimpleSerializer(queryset, many=True) # 返回数据（注意，记得.data） # Response是 from rest_framework.response import Response return Response(serializer.data) 这里需要去到之前创建的serializer.py中创建序列化器 123456class DistrictSimpleSerializer(serializers.ModelSerializer): class Meta: # District为models中的模型 model = District # fields表是只取字段为xx的数据，与前面对应 fields = ('distid', 'name') 6.URL配置可以直接配置到apidemo中的urls中去，也可以配置到当前应用的urls下，这里选择配置到当前应用的urls下 首先在apidemo中的urls中配置path(&#39;api/&#39;, include(&#39;common.urls&#39;)), 然后到当前应用的urls中配置 我们在浏览器中输入http://127.0.0.1:8000/api/districts/这个路径查看下结果 到了这里，一个简单的接口就写好了。 7.进阶一个接口数据，我们不仅仅可以查，还可以增删改，还可以做分页和做缓存 要做到增删改很简单，只需要使用一个叫ModelViewSet的模块譬如我现在有一个房源信息表，按照之前的步骤（这里models已经创建），先写views 12345678910# 导入模块from rest_framework.viewsets import ModelViewSetfrom common.serializers import HouseInfoSerializerfrom common.models import HouseInfoclass HouseInfoViewSet(ModelViewSet): # 查询房源信息 queryset = HouseInfo.objects.all() # 序列化数据 serializer_class = HouseInfoSerializer 然后完善根据需要写序列化器，这里只写HouseInfoSerializer，写法与之前一样，这里的__all__表示取所有 1234class HouseInfoSerializer(serializers.ModelSerializer): class Meta: model = HouseInfo fields = '__all__' 最后写URL，同样写在当前应用的urls下，不过写法有点不同，需要配置路由，不需要再写到urlpatterns列表中 123456789# 导入模块from rest_framework.routers import SimpleRouter# 配置路由器router = SimpleRouter()# 注册路由器router.register('houseinfos', HouseInfoViewSet)# 将路由中的url加到urlpatterns中urlpatterns += router.urls 完成后可以进入http://127.0.0.1:8000/api/houseinfos/查看，增加在最下方，更新在每个具体数据的最下方（有时候它会隐藏，需要点击HTML form才能看见），而删除在最上方有个红色的DELETE按钮。 分页有几种方式: 页码分页 - PageNumberPagination 偏移分页 - LimitOffsetPagination 游标分页 - CursorPagination 这里讲一讲页码分页，首先需要去apidemo的settings.py中配置这样一段代码，使用默认分页 1234REST_FRAMEWORK = &#123; 'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination', 'PAGE_SIZE': 5,&#125; 然后再去common中的utils.py中去写分页类 12345678# 导入模块from rest_framework.pagination import PageNumberPaginationclass HouseInfoPagination(PageNumberPagination): \"\"\"自定义房源信息分页类\"\"\" page_size_query_param = 'size' max_page_size = 10 ordering = 'houseid' 最后看一下结果 在查询的时候，我们还可以做一些数据筛选 首先去common下的utls.py中写一下我们要筛选的内容 1234567891011121314151617181920212223242526272829303132# 导入模块import django_filtersfrom django.db.models import Qfrom django_filters import FilterSetclass HouseInfoFilterSet(FilterSet): # 面积（大于等于minarea，小于等于maxarea） minarea = django_filters.NumberFilter(field_name='area', lookup_expr='gte') maxarea = django_filters.NumberFilter(field_name='area', lookup_expr='lte') # 楼层 minfloor = django_filters.NumberFilter(field_name='floor', lookup_expr='gte') maxfloor = django_filters.NumberFilter(field_name='floor', lookup_expr='lte') # 最高楼层 mintotalfloor = django_filters.NumberFilter(field_name='totalfloor', lookup_expr='gte') maxtotalfloor = django_filters.NumberFilter(field_name='totalfloor', lookup_expr='lte') # 价格 minprice = django_filters.NumberFilter(field_name='price', lookup_expr='gte') maxprice = django_filters.NumberFilter(field_name='price', lookup_expr='lte') # 关键字筛选， keyword = django_filters.CharFilter(method='filter_by_keyword') # 关键字筛选的方法 @staticmethod def filter_by_keyword(queryset, key, value): # Q查询，|表示条件或，__contains相当于包含。还有其他的方法 # __startswith: 以什么开始 # __endswith: 以什么结束 # 在这些方法前面加个i表示不区分大小写，比如__icontains queryset = queryset.filter(Q(title__contains=value) | Q(direction__contains=value) | Q(detail__contains=value) | Q(street__contains=value)) return queryset 再修改views.py的内容，这里顺便把排序也做了 1234567891011121314151617# 导入模块from rest_framework.viewsets import ModelViewSetfrom common.utils import HouseInfoFilterSet, HouseInfoPaginationfrom common.serializers import HouseInfoSerializerclass HouseInfoViewSet(ModelViewSet): # 查询房源信息 queryset = HouseInfo.objects.all() # DjangoFilterBackend - 数据筛选 # OrderingFilter - 排序 filter_backends = (DjangoFilterBackend, OrderingFilter) # 选择筛选方式（引入自己写的筛选类） filterset_class = HouseInfoFilterSet # 排序方式，可以选择以houseid, area, price ordering_fields = ('houseid', 'area', 'price') # 序列化数据 serializer_class = HouseInfoSerializer 最后查看下结果，点击过滤器就可以筛选我们想要的数据了","tags":[]},{"title":"Linux安装Python3,MySQL,Nginx和mariaDB","date":"2020-01-08T12:59:25.110Z","path":"2020/01/08/Linux安装Python3,MySQL,Nginx和mariaDB/","text":"安装Python3 安装依赖项yum install -y zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel libffi-devel 下载Python3源代码wget https://www.python.org/ftp/python/3.7.6/Python-3.7.6.tar.xz 解压缩和解归档xz -d Python-3.7.6.tar.xztar -xvf Python-3.7.6.tar 执行安装前的配置cd Python-3.7.4./configure –prefix=/usr/local/python37 –enable-optimizations 构建和安装make &amp;&amp; make install 注册环境变量vim ~/.bash_profile PATH=$PATH:/usr/local/python37/binexport PATH 安装Nginx：yum install -y nginxsystemctl start nginxsystemctl stop nginx 安装MariaDB：yum install -y mariadb mariadb-serversystemctl start mariadbmysql -u root 安装MySQL： 清除掉所有跟mariadb相关的东西yum list installed | grep mariadb | awk ‘{print $1}’ | xargs yum erase -y 清理之前的数据和日志文件（如果存在）rm -rf /var/lib/mysqlrm -f /var/log/mysqld.log 下载MySQL官方提供的RPM包并解归档wget https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.28-1.el7.x86_64.rpm-bundle.tartar -xvf mysql-5.7.28-1.el7.x86_64.rpm-bundle.tar 安装依赖库yum install -y libaio 使用rpm包管理工具安装MySQLrpm -ivh mysql-community-common-5.7.28-1.el7.x86_64.rpmrpm -ivh mysql-community-libs-5.7.28-1.el7.x86_64.rpmrpm -ivh mysql-community-client-5.7.28-1.el7.x86_64.rpmrpm -ivh mysql-community-server-5.7.28-1.el7.x86_64.rpm 启动服务查看随机密码systemctl start mysqldcat /var/log/mysqld.log | grep password 用客户端工具连接MySQLmysql -u root -p 修改root用户口令set global validate_password_policy=0;set global validate_password_length=6;alter user ‘root’@’localhost’ identified by ‘123456’;","tags":[]},{"title":"超详细创建Django项目并存在Gitee仓库中","date":"2020-01-06T03:35:21.449Z","path":"2020/01/06/超详细创建Django项目并存在Gitee仓库中/","text":"超详细创建Django项目并存在Gitee仓库中123456说明:已做免密是配置,复制仓库ssh的URL,若未做免密配置,请选择https的URL本文是已做免密设置,与未作免密配置的差别就在于连接仓库的时候是否验证而已工作时,项目一般情况都是直接git clone公司的,不用自己去创建.以后有时间将用具体的一个案例来讲解Djiango框架,本文是其前置步骤注意：本文需要一定的基础知识.同时注释符号均以//表示，未严格根据各语言进行修改！！！最后更新日期 - 2020.1.11 1.创建全局豆瓣镜像(提高下载速度)windows环境下:首先进入cmd 1234567891011Administrator@DESKTOP-VJ0GDUL MINGW64 ~$ cdAdministrator@DESKTOP-VJ0GDUL MINGW64 ~$ mkdir pipAdministrator@DESKTOP-VJ0GDUL MINGW64 ~$ cd pipAdministrator@DESKTOP-VJ0GDUL MINGW64 ~/pip$ vim pip.ini 写入[global]index-url=https://pypi.doubanio.com/simple linux环境下:在命令行下键入 1234567891011Administrator@DESKTOP-VJ0GDUL MINGW64 ~$ cdAdministrator@DESKTOP-VJ0GDUL MINGW64 ~$ mkdir .pipAdministrator@DESKTOP-VJ0GDUL MINGW64 ~$ cd .pipAdministrator@DESKTOP-VJ0GDUL MINGW64 ~/pip$ vim pip.conf // 写入[global]index-url=https://pypi.doubanio.com/simple 2.安装django1234567891011121314Administrator@DESKTOP-VJ0GDUL MINGW64 /d$ pip install django==2.2.9Looking in indexes: https://pypi.doubanio.com/simpleCollecting django==2.2.9 Downloading https://pypi.doubanio.com/packages/cb/c9/ef1e25bdd092749dae74c95c2707dff892fde36e4053c4a2354b2303be10/Django-2.2.9-py3-none-any.whl (7.5MB)Requirement already satisfied: sqlparse in c:\\users\\administrator\\appdata\\local\\programs\\python\\python37\\lib\\site-packages (from django==2.2.9) (0.3.0)Requirement already satisfied: pytz in c:\\users\\administrator\\appdata\\local\\programs\\python\\python37\\lib\\site-packages (from django==2.2.9) (2019.3)Installing collected packages: django Found existing installation: Django 2.1.14 Uninstalling Django-2.1.14: Successfully uninstalled Django-2.1.14Successfully installed django-2.2.9You are using pip version 19.0.3, however version 19.3.1 is available.You should consider upgrading via the 'python -m pip install --upgrade pip' command. 3.创建项目123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115// 创建django项目Administrator@DESKTOP-VJ0GDUL MINGW64 /d$ django-admin startproject djangocaseAdministrator@DESKTOP-VJ0GDUL MINGW64 /d$ cd djangocase/// 创建仓库Administrator@DESKTOP-VJ0GDUL MINGW64 /d/djangocase$ git initInitialized empty Git repository in D:/djangocase/.git/ // 设置忽略文件(写入vevn,.idea和http://gitignore.io/这个网址生成的(windows,macOS,Linux,python,Pycharm))Administrator@DESKTOP-VJ0GDUL MINGW64 /d/djangocase (master)$ vim .gitignore// 写入依赖项// Django==2.2.9,django-jet,django-redis,mysqlclient等Administrator@DESKTOP-VJ0GDUL MINGW64 /d/djangocase (master)$ vim requirements.txt// 将文件添加到缓存区Administrator@DESKTOP-VJ0GDUL MINGW64 /d/djangocase (master)$ git add .warning: LF will be replaced by CRLF in .gitignore.The file will have its original line endings in your working directorywarning: LF will be replaced by CRLF in requirements.txt.The file will have its original line endings in your working directory// 查看git状态Administrator@DESKTOP-VJ0GDUL MINGW64 /d/djangocase (master)$ git statusOn branch masterNo commits yetChanges to be committed: (use \"git rm --cached &lt;file&gt;...\" to unstage)​ new file: .gitignore​ new file: djangocase/__init__.py​ new file: djangocase/settings.py​ new file: djangocase/urls.py​ new file: djangocase/wsgi.py​ new file: manage.py​ new file: requirements.txt// 将缓存区中的内容全部提交到git本地仓库中Administrator@DESKTOP-VJ0GDUL MINGW64 /d/djangocase (master)$ git commit -m '项目初始版本'[master (root-commit) a4e363f] 项目初始版本 7 files changed, 450 insertions(+) create mode 100644 .gitignore create mode 100644 djangocase/__init__.py create mode 100644 djangocase/settings.py create mode 100644 djangocase/urls.py create mode 100644 djangocase/wsgi.py create mode 100644 manage.py create mode 100644 requirements.txt// 查看提交日志Administrator@DESKTOP-VJ0GDUL MINGW64 /d/djangocase (master)$ git logcommit a4e363f1ab001cb89f35c02058d7097ef4468e66 (HEAD -&gt; master)Author: Your Name &lt;you@example.com&gt;Date: Mon Jan 6 09:56:10 2020 +0800项目初始版本// 设置版本号Administrator@DESKTOP-VJ0GDUL MINGW64 /d/djangocase (master)$ git tag v0.1Administrator@DESKTOP-VJ0GDUL MINGW64 /d/djangocase (master)$ git logcommit a4e363f1ab001cb89f35c02058d7097ef4468e66 (HEAD -&gt; master, tag: v0.1)Author: Your Name &lt;you@example.com&gt;Date: Mon Jan 6 09:56:10 2020 +0800项目初始版本// 关联远程仓库Administrator@DESKTOP-VJ0GDUL MINGW64 /d/djangocase (master)$ git remote add origin git@gitee.com:wang_ba_tian/djangocase.git // 查看关联情况Administrator@DESKTOP-VJ0GDUL MINGW64 /d/djangocase (master)$ git remote -vorigin git@gitee.com:wang_ba_tian/djangocase.git (fetch)origin git@gitee.com:wang_ba_tian/djangocase.git (push)// 将本地仓库的内容提交到远程仓库对应的分支上, 如果分支不存在会自动创建Administrator@DESKTOP-VJ0GDUL MINGW64 /d/djangocase (master)$ git push -u origin masterEnumerating objects: 10, done.Counting objects: 100% (10/10), done.Delta compression using up to 8 threadsCompressing objects: 100% (9/9), done.Writing objects: 100% (10/10), 4.82 KiB | 1.20 MiB/s, done.Total 10 (delta 0), reused 0 (delta 0)remote: Powered by GITEE.COM [GNK-3.8]To gitee.com:wang_ba_tian/djangocase.git * [new branch] master -&gt; master Branch 'master' set up to track remote branch 'master' from 'origin'.Administrator@DESKTOP-VJ0GDUL MINGW64 /d/djangocase (master)$ git logcommit a4e363f1ab001cb89f35c02058d7097ef4468e66 (HEAD -&gt; master, tag: v0.1, origin/master)Author: Your Name &lt;you@example.com&gt;Date: Mon Jan 6 09:56:10 2020 +0800项目初始版本Administrator@DESKTOP-VJ0GDUL MINGW64 /d/djangocase (master)$ 1注意:远程仓库创建完毕,本地文件可以删除.上诉步骤略显麻烦,仅作为初学者练习使用 4.用Pycharm远程clone项目4.1 克隆项目在Pycharm中git下仓库(url:git@gitee.com:wang_ba_tian/djangocase.git) 4.2 创建虚拟环境在file下的setting创建虚拟环境 点击选择add 就用默认的数据,直接点ok 创建成功后的样子如下 4.3 下载安装依赖项创建成功后在Pycharm左下方的Termial中下载依赖项 (venv) E:\\PythonProject\\djangocase&gt;pip install -r requirements.txt 更新requirements.txt中的依赖项(venv) E:\\PythonProject\\djangocase&gt;pip freeze &gt; requirements.txt 4.4 添加配置在下载的同时,添加配置 配置完成后点ok,此时依赖环境也应该安装完成了,可以在even中查看这些东西 4.5 创建应用在Pycharm左下方的Termial中采用以下两种方法创建应用 ~ python manage.py startapp 应用名字 ~ django-admin startapp 应用名字 以创建car为例 4. 6 修改文件配置修改项目下与项目文件同名的文件夹(比如我的djangocase)下的settings.py文件内容 … INSTALLED_APPS = [ … // 添加应用 ‘car’, ] …//配置数据库DATABASES = { ‘default’: { // 数据库类型 ‘ENGINE’: ‘django.db.backends.mysql’, // 数据库名字 ‘NAME’: ‘djangocase’, // 数据库地址 ‘HOST’: ‘本地或者服务器地址’, // 端口 ‘POST’: 3306, // 数据库用户名 ‘USER’: ‘用户名’, // 密码 ‘PASSWORD’: ‘密码’, // 编码方式 ‘CHARSET’: ‘utf8’, // 设置时区 ‘TIME_ZONE’: ‘Asia/Chongqing’ }}… // 配置语言 LANGUAGE_CODE = ‘zh-hans’ //配置时区TIME_ZONE = ‘Asia/Chongqing’…// 配置静态资源路径STATICFILES_DIRS = [os.path.join(BASE_DIR, ‘static’)] STATIC_URL = ‘/static/‘ 至此,项目创建完成,点击运行, 若小火箭升空 那么恭喜你,可以开始你的项目编写了.","tags":[]},{"title":"Redis数据库总结","date":"2019-12-28T05:59:55.329Z","path":"2019/12/28/Redis数据库总结/","text":"Redis的安装与使用一、软件安装及基本命令1.Linux软件安装和部分命名:a. 源代码构建安装​ 安装Redis ​ ~ wget http://download.redis.io/releases/redis-5.0.7.tar.gz ​ ~ gunzip redis-5.0.7.tar.gz ​ ~ tar -xvf redis-5.0.7.tar ​ ~ cd redis-5.0.7 ​ ~ make &amp;&amp;make install ​ 安装git官方最新版 ​ ~ wget https://mirrors.edge.kernel.org/pub/software/scm/git/git-2.24.1.tar.xz ​ ~ xz -d git-2.24.1.tar.xz ​ ~ tar -xvf git-2.24.1.tar ​ ~ cd git-2.24.1 ​ ~ make &amp;&amp;make install b. Linux系统启停服务​ systemctl start 服务名 - 开启服务 ​ systemctl stop服务名 - 停止服务 ​ systemctl restart 服务名 - 重启服务 ​ systemctl status 服务名 - 查看服务状态 ​ systemctl enable 服务名 - 开机自启 ​ systemctl disable 服务名 - 禁止自启 c. ps命令 - 用于显示当前进程 (process) 的状态。​ 当不清楚redis是否已经开启，或者无法关闭redis需要强行关闭时，可以用该命令查出redis的进程号。 ​ ps -ef | grep -E “正则表达式” /grep 字符串 |grep -v 字符串 ​ -E后跟正则表达式， ​ -v 不搜索。 ​ ps -ef | grep redis-server | grep -v grep | awk ‘{print $2}’ - {print $2} 拿第二列 ​ ps -ef | grep redis-server | grep -v grep | awk ‘{print $NF}’ - {print $NF} 拿最后一列 ​ ps -ef | grep redis-server | grep -v grep | awk ‘{print $0}’ | xargs kill - xargs 将行编程列，然后kill所有ps出来的命令 ​ pkill “进程名” - 结束带有进程名的进程 2. Redis相关命令1)Redis服务的启动​ redis-server –requirepass 123456 –bind ip地址 –port 端口号 &gt;&gt; redis.log &amp; ​ 启动redis服务，并且设置密码，重定向到redis.log文件，并且放到后台运行， ​ 命令后面加&amp; —–&gt;将命令放后台运行 ​ –port 端口号 -设置端口 ​ –bind ip地址 - 绑定ip地址(从自身网卡ip选择) ​ –requirepass、–bind、–port、重定向等可选择性书写。 ​ ​ jobs - 查看后台运行命令(手动添加到后台的) ​ fg %1 - 将后台命令放到前台（占用shell） ​ Ctrl +z - 将前台命令暂停并放到后台 ​ bg %编号 - 将暂停的命令放在后台运行 ​ netstat -ntlp - 查看正在占用的端口号 ​ docker stop 进程名 - 停止正则进行的进程 ​ redis-cli -p 端口号 -a 密码 -h 主机 ​ 设置密码之后用 redis-cli登录也可进如redis命令行模式，但在验证密码前是什么操作都做不了的 ​ 在redis命令行模式下输入 auth 密码 - -&gt;也可正常登录 ​ 2) Redis中：​ shutdown save - 退出并保存 ​ save bgsave - 保存 ​ select N - 切换到第N+1个数据库（N范围为0-15） ​ flushdb - 清空当前数据库的数据 ​ flushall - 清空所有数据库的数据 ​ keys * - 查看所有键 ​ dbsize - 查看数据库大小(键值对数量) ​ exists - 判断指定的键是否存在 ​ type - 查看键对应值的数据类型 ​ ttl 键 - 查看键值对存活时间 ​ 显示-1 - 说明永不过期 ​ 显示-2 - 说明已经不存在了 ​ 3) Redis中的核心数据类型​ a. 字符串 ​ set： ​ set key value ex seconds –&gt;添加一个键值对，并且设置它的生存时间(秒) ​ setex key seconds value –&gt; 添加一个键值对，并且设置他的生存时间(秒) ​ set key value nx –&gt; 若key存在，则设置value，否则不作为 ​ setnx key value –&gt;若key存在，则设置value，否则不作为 ​ set key value xx –&gt;只在key存在的时候，才对key进行设置操作 ​ psetex key milliseconds value –&gt;添加一个键值对，并且设置它的生存时间(毫秒) ​ get : ​ get key –&gt; 若key存在，那么返回key的value(如果value不是字符串，那莪返回一个错误)，否则返回特殊值nil ​ getset key value –&gt;将key的值设置为value，并返回key在被设置之前的旧值。若key没有旧值，则返回nil,当key存在但不是字符串类型时，返回一个错误。 ​ 其他操作: ​ strlen key –&gt;返回key储存的字符串值的长度 ​ append key value –&gt;将value追加到key现有值的末尾，若可不存在，则创建新的key和value。 ​ setrange key offset value –&gt;从偏移量offset开始，用value参数复写key存储的字符串值，当key不存在的时候，当空白字符串处理，若偏移量大于原字符串长度，那么超过原字符串的部分用零字节(‘\\x00’)进行填充 ​ getrange key start end –&gt; 返回key储存的字符串指定部分，从start开始，到end结束(包括start和end)，负偏移量表示从字符串末尾开始技术，-1表示最后一个字符，-2表示倒数第二个。 ​ b. 哈希表 - hash ​ hset key field value –&gt; 添加hash类型键值对 ​ hmset key field1 value1 field2 value2 … –&gt; 添加多组hash类型键值对 ​ hget key filed –&gt; 获取hash类型字段对应的值 ​ hmget key filed1 filed2… –&gt; 获取hash类型多个字段对应的值 ​ hgetall key –&gt; 获取hash类型所有的字段和对应的值 ​ hkeys key –&gt; 获取hash类型所有的字段 ​ hvals key –&gt; 获取hash类型所有字段的值 ​ hexists key field –&gt; 判断hash类型某个字段是否存在 ​ c. 列表 - list ​ lpush key value1 value2 value3… —&gt; 在左边添加元素 ​ rpush key value1 value2 value3… –&gt; 在右边添加元素 ​ lpop key –&gt; 从左边移除一个元素 ​ rpop key –&gt; 从右边移除一个元素 ​ lindex key index –&gt; 查看列表指定位置元素 ​ lrange key start end –&gt; 查看列表指定范围的元素 ​ llen key –&gt; 查看列表元素个数 ​ lrem key N value –&gt; 删除列表中指定元素 ​ d. 集合 ​ sadd key value1 value2 value3… –&gt;添加元素 ​ srem key value1 value2 value3… –&gt;删除元素 ​ spop –&gt;获取随机元素 ​ smembers key –&gt;查看所有元素 ​ scard –&gt;查看元素个数 ​ sismember key value –&gt; 查看集合中有没有指定元素 ​ sinter key1 key2 –&gt; 交集 ​ sunion key1 key2 –&gt;并集 ​ sdiff key1 key2 –&gt;差集 ​ e .有序集合 - zset ​ zadd key score1 mem1 score2 mem2… —&gt;添加元素 ​ zrem key mem —&gt;删除元素 ​ zrange key start end —&gt; 升序查看元素 ​ zrevrange key start end —&gt; 降序查看元素 ​ zscore key mem —&gt;查看元素对应的score ​ zincrby key value mem —&gt;增加元素的score值 ​ c. LBS应用 —— Location-Based Service — 基于位置服务 二、实际应用 准备一个mysql数据库，创建表并存入数据 创建一个python工程 简单应用，直接上代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import redisimport jsonimport pickle\"\"\"序列化：把一个对象变成字符串(str) 或者字节串(bytes)反序列化：把字符串(str) 或者字节串(bytes)还原成对象json - dumps/loads -基于字符串pickle - dumps/loads -基于字节串\"\"\"# 连接redis（注意：redis必须开启，否则无法连接）client = redis.Redis(host='47.98.172.19', port=6379, password='123456')# client.ping()的返回结果是True,，可以用来检测是否连接成功if client.ping(): # 所有Linux下的redis操作在redis模块下一样 # 创建字符串键值对 client.set('username', 'wangx', ex=1000) client.set('pwd', '123456', ex=1000) client.set('gender', '男', ex=1000) print(client.ttl('username')) # value直接输出的结果将会是字节串，需要转换一下 # bytes ---decode('utf-8')---&gt;str # str ----encode('utf-8')---&gt;bytes # 字符串 print(client.get('username').decode('utf-8')) print(client.ttl('pwd')) print(client.get('pwd').decode('utf-8')) # 列表 client.rpush('list1', 1, 2, 3, 4, 5) list1 = client.lrange('list1', 0, -1) print(list(map(int, list1))) # 集合 client.sadd('set1', 10, 20, 30, 40) set1 = client.smembers('set1') print(set(map(int, set1))) # 有序集合 # zadd的第二个参数是mapping client.zadd('zset1', &#123; '小明': 100, '小红': 123, '小王': 70 &#125;) zset1 = client.zrange('zset1', 0, -1) print(list(map(bytes.decode, zset1))) print(client.zscore('zset1', '小明'))else: print('连接失败！！！') 与mysql结合 123456789101112131415161718192021222324252627282930313233343536373839404142434445import pickleimport pymysqlimport redisdef load_depts_from_db(): # 连接mysql数据库 conn = pymysql.connect(host='*.*.*.*', port=3306, user='root', password='123456', database='hrs',charset='utf8') depts = () try: with conn.cursor() as cursor: # 查询数据 cursor.execute('select dno,dname,dloc from tb_dept') # 将查询结果放入depts中 depts = cursor.fetchall() # 返回depts return depts except pymysql.MySQLError as err: # 若数据库出错，返回原因 print(err) finally: # 关闭数据库 conn.close()def main(): # 连接redis client = redis.Redis(host='*.*.*.*', port=6379, password='123456') # 获取redis中depts的值 data = client.get('depts') # 当值存在，取出值并反序列化 if data: depts = pickle.loads(data) # 当值不存在 else: # 从mysql数据库中取出存入depts， depts = load_depts_from_db() # 在redis中创建键值对 client.set('depts', pickle.dumps(depts)) # 打印结果 print(depts)if __name__ == '__main__': main()","tags":[]},{"title":"MySQL数据库基础总结","date":"2019-12-28T05:59:55.327Z","path":"2019/12/28/MySQL数据库基础总结/","text":"MySQL数据库基础一、SQL基础SQL又叫结构化查询语言，分为三大类：DDL(数据定义语言)、DML(数据操作语言)、DCL(数据控制语言)DDL：create(创建数据库和表)、drop(删除数据库和表)、alter(修改数据库和表)DML：insert(增)、delete(删)、update(改)、select(查)DCL：grant(授权)、revoke(召回授权) sql的注释是在注释前加–sql中sql的关键字不区分大小写sql语句结束后要加分号 1.DDL(数据定义语言)1.1 创建数据库 create database 数据库名称; – 创建指定数据库，如果这个数据可已经存在，会报错create database if not exists 数据库名称; – 当指定的数据库不存在的时候创建对应的数据库create database if not exists 数据库名称 default charset utf8; – 创建数据库的时候指定数据文件编码方式 1create database if not exists school default charset utf8; 1.2 删除数据库 drop database 数据库名; - 若数据库不存在会报错drop database if exists 数据库名称; - 如果数据库存在，则删除数据库 12drop database school;drop database if exists school; 1.3 切换/使用数据库use 数据库名; – 切换到/使用指定数据库，切换后所有数据库相关操作都是针对这个数据库 1use school; 1.4 创建表(数据库文件是通过表来存数据的) create table 表名/create table if not exists 表名(字段名1 类型名1 约束1,字段名2 类型名2 约束2,字段名3 类型名3 约束3, …)注意：字段中一定要有一个字段来作为主键；主键要求不能为空，并且是唯一的，而且数据类型是整型类型名：必须是当前数据库支持的数据类型mysql常用的数据类型：int，float，double，varchar(字符串)/text(字符串)，bit(布尔，0和1)，date/datetime(日期和时间)约束：not null(非空约束), unique(唯一约束), default(默认值约束), primary key(主键约束), foreign key(外键约束), auto_increment(自动增加)注意：约束可以没有也可以有多个 123456789create table if not exists tb_students(stuid int primary key auto_increment,stuname varchar(4) not null,stubirth date,stugender bit default 1,stutel VARCHAR(11) unique-- primary key(stuid) -- 主键约束还可以单独约束); 1.5 删除表 drop table if exists 表名; –删除指定的表 1drop table if exists tb_students 1.6 修改表 1) 添加字段alter table 表名 add column 字段名 字段类型 约束; 1alter table tb_students add column stuaddr varchar(200); 2) 删除字段alter table 表名 drop column 字段名; 1alter table tb_students drop column stuaddr; 3) 修改字段名alter table 表名 change 原字段 新字段 新的类型; 1alter table tb_students change tel stutel varchar(11); 4) 添加删除约束a.在创建表或者添加字段的时候，直接在字段后面添加约束b.通过修改表的方式添加和删除约束。alter table 表名 add constraint 约束索引 约束名(字段)； - 给指定字段添加指定约束(只能添加唯一约束和主键约束)alter table 表名 drop constraint 约束索引名；- 删除指定约束 12ALTER TABLE tb_student add constraint unique_colid UNIQUE(cid);ALTER TABLE tb_student DROP INDEX unique_colid; 2.DML语言数据库操作语言主要提供表中数据的曾、删、改、查操作 2.1 insert insert into 表名 values(值1, 值2, 值3…); - 按表中字段的顺序依次给每个字段赋值，最终形成一条新的记录insert into 表名(字段1, 字段2, 字段3…) values(值1, 值2, 值3…); - 按指定顺序给指定字段赋值insert into 表名(字段1, 字段2, 字段3…) values(值11, 值21, 值31…),(值12, 值22, 值32…),(值13, 值23, 值33…)…; - 同时插入多条记录 123456789101112insert into tb_students values(1001, &#39;宝儿姐&#39;, &#39;2019-10-20&#39;, 0, &#39;13345678941&#39;);insert into tb_students(stuname,stutel,stubirth) values(&#39;张楚楠&#39;, &#39;18912345678&#39;, DATE(NOW()));insert into tb_students(stuname,stutel,stubirth, stugender) values(&#39;徐三&#39;, &#39;18965432171&#39;, &#39;1987-3-25&#39;, 1),(&#39;徐四&#39;, &#39;18965432145&#39;, &#39;1990-9-13&#39;, 1),(&#39;夏禾&#39;, &#39;18965432134&#39;, &#39;1993-2-1&#39;, 0),(&#39;柳妍妍&#39;, &#39;18912345659&#39;, &#39;2000-10-20&#39;, 0),(&#39;龚庆&#39;, &#39;18965432132&#39;, &#39;1998-4-9&#39;, 1),(&#39;吕良&#39;, &#39;18965432133&#39;, &#39;1987-8-25&#39;, 1),(&#39;窦梅&#39;, &#39;18965432124&#39;, &#39;1980-3-24&#39;, 0),(&#39;沈冲&#39;, &#39;18965432135&#39;, &#39;1991-2-19&#39;, 1),(&#39;高宁&#39;, &#39;18965432136&#39;, &#39;1985-6-20&#39;, 1); 补充1：值的问题字符串 - 用引号引起来日期 - 1)日期字符串 2)date(now()) - 当前日期 year(now())-当前年 month(now())-当前月 day(now())-当前日布尔 - 0或1 2.2 delete delete from 表名; - 删除当前表中的所有记录(清空表) delete from 表名 where 条件; - 删除所有满足条件的记录 12345678910delete from tb_students where stuname&#x3D;&#39;宝儿姐&#39;;delete from tb_students where not stuname&#x3D;&#39;夏禾&#39;; -- 删除stuname不是夏禾的所有记录delete from tb_students where stuid&gt;1014; -- 删除stuid值大于1014的所有记录delete from tb_students where stuid&gt;1012 and stugender&#x3D;0; -- 删除stuid大于1012并且stugender是0的所有记录delete from tb_students where stuname in (&#39;宝儿姐&#39;,&#39;徐三&#39;,&#39;许思&#39;,&#39;徐四&#39;); -- 删除stuname的值在(&#39;宝儿姐&#39;,&#39;徐三&#39;,&#39;许思&#39;,&#39;徐四&#39;)中的所有记录delete from tb_students where stubirth between &#39;1980-0-1-1&#39; and &#39;1989-12-31&#39;; -- 删除stubrith在&#39;1980-0-1-1&#39;到&#39;1989-12-31&#39;之间的所有记录delete from tb_students where stubirth is null; -- 删除stubrith为空的记录delete from tb_students where stuname like &#39;徐%&#39;; -- 删除stuname是徐开头的所有记录delete from tb_students where stutel like &#39;%8&#39;; -- 删除stutel最后一位是8的所有记录delete from tb_students where stutel like &#39;__8%&#39;; -- 删除stutel第三位是8的所有记录 补充：mysql条件语句的写法(筛选)比较运算：=,&lt;&gt;(不等于),&gt;,&lt;,&gt;=,&lt;=逻辑运算: and, or, not集合包含：in范围: BETWEEN…and判断是否为空：is null, is not null筛选：like(% - 任意个任意字符，% - 一个任意字符) 2.3 update 1alter table tb_students add column stuaddr varchar(255); update 表名 set 字段1=值1,字段2=值2,字段3=值3…; – 将指定表中所有记录中指定的字段修改成指定的值 1update tb_students set stuaddr&#x3D;&#39;成都&#39;; update 表名 set 字段1=值1,字段2=值2,字段3=值3… where 条件; – 将满足条件的记录的指定字段设置为指定的值 1update tb_students set stuaddr&#x3D;&#39;重庆&#39; where stugender&#x3D;0; 2.4 select select * from 表名; - 获取指定表中所有记录中所有字段的数据 1SELECT * FROM tb_students; 映射select 字段1,字段2,字段3…from 表名; - 获取表中所有记录指定字段的数据 1SELECT stuname,stutel FROM tb_students; 列重命名select 字段1 as ‘新字段名1’,字段2, 字段3…from 表名;as 可以省略; 1SELECT stuname as &#39;姓名&#39;,stutel as &#39;电话&#39; FROM tb_students; 结果重新赋值(主要针对布尔)select if(字段1，值1，值2) from 表名; - mysql特有写法，如果if中对应的字段的值是1，最后结果是值1，否则是值2SELECT if(stugender, ‘男’, ‘女’) as ‘性别’ FROM tb_students; 12select case 字段 when 1 then 值1 else 值2 end from 表名; - 通用写法SELECT CASE stugender WHEN 1 THEN &#39;男&#39; else &#39;女&#39; end as &#39;性别&#39; FROM tb_students; 列合并(查询的时候，将多个字段合并成一个数据返回结果)select concat(字段1, 字段2…) from 表名; 1SELECT CONCAT(stuid,stuname) FROM tb_students; 筛选select * from 表名 where 条件; 12select stuname,stutel from tb_students where stugender=0;SELECT * FROM tb_students where stuname LIKE '徐%'; 排序select * from 表名 order by 字段; - 将查询结果按指定字段的值从小到大排序select * from 表名 order by 字段 asc; - 将查询结果按指定字段的值从小到大排序 12SELECT * FROM tb_students ORDER BY stubirth;SELECT * FROM tb_students WHERE stugender&#x3D;1 ORDER BY stubirth; select * from 表名 order by 字段 desc; - 将查询结果按指定字段的值从大到小排序 12SELECT * FROM tb_students ORDER BY stubirth DESC;SELECT * FROM tb_students WHERE stugender&#x3D;1 ORDER BY stubirth DESC; 3. DCL(数据控制语言)DCL主要提供授权和召回授权以及事务等相关功能1.用户管理 1) 创建用户(root账号登录数据库后才能有创建用户的权限)create user ‘用户名‘@’登陆地址’; - 创建数据用户，该用户登陆不需要密码create user ‘用户名‘@’登陆地址’ identified by ‘密码’;说明：用户名-随便命名；登陆地址 - ip地址/localhost(本机)/%(任意位置) 12CREATE USER 'user1'@'localhost';CREATE USER 'user2'@'%' IDENTIFIED BY '123456'; 2)删除drop user 用户名; USER user2;```12345678910112.授权管理1)授权grant 权限类型 on 数据库.表 to 用户名;说明：权限类型：insert，delete，update，select，create，drop...,add privileges(所有权限)&#96;&#96;&#96;&#96;&#96;&#96;mysqlgrant SELECT on school.tb_student to &#39;user1&#39;@&#39;localhost&#39;;grant DELETE,UPDATE on school.tb_student to &#39;user1&#39;@&#39;localhost&#39;;GRANT SELECT ON hrs.* to &#39;user1&#39;@&#39;localhost&#39;;&#96;&#96;&#96; 2) 召回授权revoke 授权类型 on 数据库.表 from 用户名； 12revoke DELETE on school.tb_student FROM &#39;user1&#39;@&#39;localhost&#39;;REVOKE SELECT on hrs.* FROM &#39;user1&#39;@&#39;localhost; 二、外键约束1.E-R实体关系图E-R实体关系图是通过图表的形式来表示数据库中的表和字段以及表和表之间的关系表和表之间的关系主要有四种: 1对1，1对多，多对1，多对多 2.外键约束外键约束：让字段的值取值范围在另外一张表的主键中怎么添加外键约束：1)保证当前表中有一个字段能够保存另外一张表的主键 2)添加外键约束不同对应关系外键的添加要求不同：一对一：可以添加到任意一张表中，只能添加到一张表中一对多和多对一：添加到多的那张表中多对多：两张表没有办法建立多对多的对应关系，需要一个第三张表才行 12ALTER TABLE tb_student ADD COLUMN cid int COMMENT &#39;所在学院&#39;;-- 在学生表中添加新的字段，保存学院表的主键 3.添加约束的方式3.1 在创建表或者添加字段的时候，直接在字段后面添加约束3.2 通过修改表的方式添加和删除约束。alter table 表名 add constraint 约束索引 约束名(字段)； - 给指定字段添加指定约束(只能添加唯一约束和主键约束)alter table 表名 drop constraint 约束索引名；- 删除指定约束 12ALTER TABLE tb_student add constraint unique_colid UNIQUE(cid);ALTER TABLE tb_student DROP INDEX unique_colid; 添加外键约束alter table 表名 add constraint 约束索引名 foreign key(字段1) references 表2(字段2);给表1中的字段1添加外键约束，并且字段1的值以来表2的字段2：注意字段1和字段2不能同名 1234567ALTER TABLE tb_student ADD CONSTRAINT fk_col_stu FOREIGN KEY(cid) REFERENCES tb_college(collid);ALTER TABLE tb_teacher ADD COLUMN cid int COMMENT &#39;所在学院&#39;;ALTER TABLE tb_teacher ADD CONSTRAINT fk_col_tea FOREIGN KEY(cid) REFERENCES tb_college(collid);ALTER TABLE tb_course ADD COLUMN tid int COMMENT &#39;所属老师&#39;;ALTER TABLE tb_course add CONSTRAINT fk_tea_cou FOREIGN KEY(tid) REFERENCES tb_teacher(teaid); 创建表的时候也可以添加外键约束 3.4 删除外键约束alter table 表名 drop foreign key 外键索引; 3.5 多对多关系的外键约束1234567891011CREATE TABLE if not EXISTS tb_record(reid int auto_increment,sid int COMMENT &#39;学生外键&#39;,cid int COMMENT &#39;课程外键&#39;,redate date comment &#39;选课日期&#39;,score FLOAT comment &#39;分数&#39;,PRIMARY KEY(reid),foreign key(sid) references tb_student(stuid),FOREIGN KEY(cid) REFERENCES tb_course(couid)); 三、高级查询1.去重 select distinct 字段名 from 表名; 12SELECT distinct redate FROM tb_record ORDER BY redate DESC;SELECT DISTINCT sid FROM tb_record; 2.限制和分页限制：SELECT * FROM 表名 LIMIT N; - 查询时只获取前N条的数据分页(偏移)：1). SELECT * FROM 表名 limit M offset N; - 跳过前N条数据，获取M条数据(从N+1条数去开始，获取M条数据)2). SELECT * FROM 表名 limit M,N; - 跳过前M条数据，获取N条数据(从M+1条数去开始，获取N条数据) 1234SELECT * FROM tb_record LIMIT 5; -- 获取前5条数数据SELECT * FROM tb_record LIMIT 7 OFFSET 3; -- 跳过前3条，获取7条数据SELECT * FROM tb_record LIMIT 3,7;SELECT distinct score FROM tb_record ORDER BY score DESC LIMIT 3; -- 获取成绩前3的记录 3.聚合max(),min,sum(),avg(),count(),若某一个记录为空，那么这条记录不参与运算 - mysql 1SELECT MAX(score) FROM tb_record 4.分组select 聚合操作 from 表名 group by(字段); - 按指定字段的值对表进行分组,然后对每个分组进行聚合操作注意：分组后，除了分组字段以外，其他字段只能进行聚合操作在分组后如果加条件，需要用having代替where 123SELECT sid,avg(score) FROM tb_record GROUP BY(sid); -- 获取每个学生的平均分SELECT cid,AVG(score) FROM tb_record GROUP BY(cid); -- 获取每个学科的平均分SELECT sid,COUNT(cid) FROM tb_record GROUP BY(sid); -- 获取每个学生选课数量 5.子查询：将一个查询的结果作为另外一个查询的条件或者查询对象第一种子查询：将查询的结果作为另外一个查询的条件获取成绩是最高分的所有的学生的id 1SELECT sid,score from tb_record where score&#x3D;(SELECT MAX(score) FROM tb_record); 获取所有选了两门课以上的学生id 1SELECT sid FROM tb_record GROUP BY(sid) HAVING COUNT(cid)&gt;2; 获取所有选了两门课以上的学生id 1SELECT stuname FROM tb_student WHERE stuid in (SELECT sid FROM tb_record GROUP BY(sid) HAVING COUNT(cid)&gt;2); 第二种子查询：将一个查询的结果作为另一个查询的查询对象注意：如果要将查询结果作为查询对象，那么查询结果对应的查询必须重命名 1SELECT stuname FROM (SELECT * FROM tb_student LIMIT 3,5) as t1 WHERE stusex&#x3D;1; 1SELECT sname,saddr FROM(SELECT stuname as sname,stuaddr as saddr FROM tb_student WHERE stusex&#x3D;0) as t1 WHERE saddr&#x3D;&#39;四川成都&#39;; 6.连表查询/连接查询6.1 同时查多张表的数据SELECT 字段 FROM 表名1, 表名2, 表名3… WHERE 连接条件 查询条件;注意：如果既有连接条件，又有查询条件，查询条件必须放在连接条件的后面 – 查询所有学生的名字和学院名称 1SELECT stuname,collname FROM tb_student,tb_college WHERE tb_student.cid&#x3D;tb_college.collid; 查询每个学生的每个学科的成绩 1SELECT stuname,couname,score FROM tb_student,tb_course,tb_record WHERE tb_record.cid&#x3D;tb_course.couid and tb_student.stuid&#x3D;tb_record.sid and score&gt;70; 6.2 内连接之前的连接查询其实就是内连接，内连接有两种写法写法1：select * from 表1,表2,表3… where 连接条件 查询条件;写法2: select * from 表1 inner join 表2 on 表2连接条件 inner join 表3 on 表3连接条件… where 查询条件;注意：如果不写连接条件，最后会形成笛卡尔积现象；在方法二中，中间表必须放在前面 6.3 外连接在mysql中外连接只支持左外连接(left join)和右外连接(right join) 表1 left join 表2; - 先将表1中的记录全部取出来，按连接条件去依次来连接表2中的记录。如果表1中的记录找不到满足连接条件的表2记录，那么连接的内容就是空 表1 right join 表2; - 先将表2中的记录全部取出来，按连接条件去依次来连接表1中的记录。如果表2中的记录找不到满足连接条件的表1记录，那么连接的内容就是空 四、事务、视图和索引1. 事务如果完成一个任务需要多个操作，但是要求多个操作中只要有一个失败，那么整个任务取消，让整个数据回到任务开始前的状态，只有所有的操作都成功了，数据库才更新。这个时候就用事务 事务（Transaction），一般是指要做的或所做的事情。在计算机术语中是指访问并可能更新数据库中各种数据项的一个程序执行单元(unit)。事务应该具有4个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为ACID特性。1、原子性。一个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做。2、一致性。事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。3、隔离性。一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。4、持久性。指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。 开启事务环境 begin; 1234567BEGIN;UPDATE tb_student SET stubirth&#x3D;CURDATE() WHERE stusex&#x3D;0;DELETE FROM tb_student WHERE stuname LIKE &#39;杨%&#39;;-- 提交事务环境中的操作结果 commit;COMMIT;-- 回滚 rollback;ROLLBACK 2.视图视图是用来存储一个sql查询语句的结果，就相当于给查询语句的结果创建一张临时表，但是这个临时表不占物理内存2.1 创建视图create view 视图名 as sql查询语句; - 给sql查询语句的结果创建一张临时表2.2 使用视图视图在使用的时候和表使用的时候一样(查询)，视图一般不进行增删改的操作 获取学生学科的成绩 1234create view Vw_score_info asSELECT stuid,stuname,couid,couname,score FROM tb_student as t1,tb_course as t2,tb_record as t3WHERE t1.stuid&#x3D;t3.sid and t2.couid&#x3D;t3.cid; 查询视图和查询表一样 12345678SELECT stuname,avg(score) FROM Vw_score_info GROUP BY(stuid);use hrs;CREATE view Vw_tmp_info as SELECT eno,ename,job,mgr,dno FROM tb_emp;GRANT SELECT ON hrs.Vw_tmp_info to &#39;user1&#39;@&#39;localhost&#39;; 创建学生表的视图，要求视图中不能看到学生的生日，用学号、姓名、性别、地址和学院作为新视图中的字段名 123CREATE VIEW Vw_stu_info ASSELECT stuid as &#39;学号&#39;,stuname as &#39;姓名&#39;, IF(stusex,&#39;男&#39;,&#39;女&#39;) as &#39;性别&#39;, stuaddr as &#39;地址&#39;, collname as &#39;学院&#39;FROM tb_student,tb_college WHERE tb_student.cid&#x3D;tb_college.collid; 3.索引索引就像书的目录，记录了数据的位置，可以提高查询速度(空间换时间)一般给使用频率较高的字段添加索引，(主键自带索引 - 唯一索引) 3.1创建索引create index 索引名 on 表名(字段); - 给指定字段添加普通索引creat unique indexx 索引吗 on 表名(字段); - 给指定字段添加唯一索引(字段值为唯一的时候才能添加索引)注意：模糊查询的时候，如果以%或_开头，索引无效 explain - 获取sql语句的执行计划(主要用于检测sql语句的性能) 1234EXPLAIN SELECT * FROM tb_student WHERE stuname&#x3D;&#39;项少龙&#39;;EXPLAIN SELECT * FROM tb_student WHERE stuid&#x3D;&#39;3755&#39;;CREATE INDEX idx_stuname on tb_student(stuname); 3.2删除索引alter table 表名 drop index 索引名; 1ALTER TABLE tb_student drop INDEX idx_stuname;","tags":[]},{"title":"shell编程","date":"2019-12-20T10:32:03.065Z","path":"2019/12/20/shell编程/","text":"shell编程Shell脚本，是一种为shell编写的脚本程序。 Shell编程跟JavaScript、Python编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。 Linux的Shell种类有很多，我们主要用的是Bourne Shell(/usr.bin/sh或/bin/sh) 1.创建shell文件原则上shell程序可以写在任何文件中，但是一般会在shell文件后加后缀.sh表示当前文件是一个shell文件 shell需要可执行权限，所以创建好的shell文件需要添加x权限 2.基础语法1）注释123456# 单行注释:&lt;&lt;EOF多行注释1多行注释2多行注释3EOF 2）输出和输入echo指令就相当于python中的print函数(默认会换行) 12echo 输出内容 echo -n 输出内容 # 输出的时候不换行 printf指令（输出不能换行） 1printf 输出内容 输入指令: read 变量名 – 输入内容，并且将输入的结果保存在变量中 3）变量a. 声明变量的语法: 变量名=值 说明: a. 变量名和=, =和值之间不能有空格 ​ b. 变量名的要求和python变量名要求一样 123name='小明'age=18stu_name=小红 b. 使用变量: ​ $变量 ​ ${变量} 123age=18echo $ageage2=$&#123;age&#125; c. 只读变量 使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。 123gender='男'readonly gendergender='女' # test.sh: line 17: gender: readonly variable d. 删除变量 使用 unset 命令可以删除变量 12name='yuting'unset name 4）获取linux指令结果在shell脚本中可以直接写linux指令，在执行shell脚本的时候这些指令可以直接获取 1234567ls # ls指令ls -lh # ls指令，并且设置参数touch a.txt # 创建a.txt文件# 获取指令结果: 变量=$(指令) / 变量=`指令`lsresult=$(ls) #将ls指令的结果保存到变量lsresult中currnet_path=`pwd` 3.shell字符串shell中的字符串可以用单引号也可以使用双引号甚至可以不用引号。但是单引号中不能出现单引号字符，加\\也不行 12345678str1='abc'str2=\"abc\"str3=abcstr4='abc\\n123' #支持转义字符,但是不支持编码字符str5=\"abc\\n123\"age=18str6=\"年龄是$age\" #双引号里面可以出现变量,单引号不行 1）字符串拼接123456789str1=\"hello\"#单引号拼接str2=''$&#123;str1&#125;',world!'str3=''$str1',world!'#双引号拼接str4=\"$&#123;str1&#125;,world!\"str5=\"\"$str1\",world!\" 2）获取字符串长度12str1=\"abcd\"echo $&#123;#str1&#125; # 输出4 3）字符串提取123456# 字符串:下标:个数 --从字符串中指定下标开始获取指定个数字符,返回一个新的字符串# 字符串:下标:1 -- 获取字符串中指定下标对应的字符# 字符串:下标 -- 从指定下标开始获取到字符串最后string='hello world'echo $&#123;string:1:4&#125; # ello 4.shell数组在 Shell 中，用括号来表示数组，数组元素用”空格”符号分割开。定义数组的一般形式为： 123456789101112# 数组名=(元素1 元素2 元素3 ...)names=(小明 小红 大黄 Tom)names2=('小明''小红''大黄''Tom')names3[0]=小明names3[1]=小红names3[2]=大黄names3[3]=Tom 1）获取数组元素：${数组[下标]}1echo $&#123;names[1]&#125; # 小红 2）获取数组的长度123456nums=(100 200 300 400)# 获取数组长度length=$&#123;#nums[@]&#125;length=$&#123;#nums[*]&#125;# 获取数组指定下标对应的元素的长度length2=$&#123;#num[n]&#125; 5.运算符shell中支持的运算符有: 算术运算符、关系运算符、布尔运算符、字符串运算符 1）算术运算符：+，-，*，/，%123456789101112131415161718192021222324252627282930# 如果想要在shell完成数值运算，运算的语法: `expr 运算表达式`; 并且运算符两边必须加空格re1=10+20echo $&#123;re1&#125; # 10+20# 1.加法运算re2=`expr 10 + 20` echo $&#123;re2&#125; # 30# 2.减法运算re3=`expr 10 - 20`echo $&#123;re3&#125; # -10# 3.乘法运算re4=`expr 10 \\* 20` # 注意:使用*作为乘法运算符的时候需要前面加\\echo $&#123;re4&#125; # 200# 4.除法运算# 小数除法运算: `echo \"scale=小数点位数;数值1 / 数值2\"|bc`# 整数除法运算: `expr 数值1 / 数值2`re5=`echo \"scale=2;7 / 3\"|bc`echo $re5re6=`expr 5 / 2`echo $re6# 5.求余数re7=`expr 10 % 3`re8=`echo \"10.2 + 5.1\"|bc`echo $re8 2） 关系运算符(比较运算符)，比较的是数字大小1234567891011121314151617# -eq --- 等于,相当于 ==# -ne --- 不等于,相当于!=# -gt --- 大于# -lt --- 小于# -ge --- 大于等于# -le --- 小于等于# 使用语法: [ 值1 关系运算符 值2 ]a=100b=10# 关系运算符要配合if语句或者循环语句使用if [ $a -gt $b ]then echo a大于belse echo a不大于bfi 3）布尔运算符(逻辑运算符)12345678910111213# ! -- 逻辑非运算# -o -- 逻辑或运算# -a -- 逻辑与运算age=18score=95# 参加比赛的条件：分数大于90分并且年龄大于等于18岁if [ $age -ge 18 -a $score -gt 90 ]then echo 可以参见比赛else echo 不能参加比赛fi 4）字符串运算符1234567891011121314151617181920212223# [ 字符串1 = 字符串2 ] -- 判断两个字符串是否相等# [ 字符串1 != 字符串2 ] -- 不相等# [ -z 字符串] -- 判断字符串长度是否为0# [ -n \"字符串\" ] -- 判断字符串长度是否不为0# [ $ 字符串 ] -- 判断字符串是否是空串a=\"abc\"b=\"123\"if [ $a = $b ]then echo a和b相等else echo a和b不相等fia=\"\"if [ -n \"$&#123;a&#125;\" ]then echo a的长度不为0else echo a的长度为0fi 6. if语句12345678910111213141516171819202122232425262728语法1：if 条件语句then 满足条件执行的代码fi语法2:if 条件语句then 满足条件执行的代码else 不满足条件执行的代码fi语法3：if 条件语句1then 代码块1elif 条件语句2then 代码块2elif 条件语句3then 代码块3else 代码块Nfi 7. for循环123456789101112131415161718192021222324语法:for 变量 in 序列do 循环体done# 遍历字符串for char in \"hello word\"do echo 循环体char: $&#123;char&#125;done# 遍历数组arr1=(10 20 \"abc\")for x in $&#123;arr1[@]&#125;do echo 循环体2x: $&#123;x&#125;done# 遍历多个值for x in 10 20 \"你好\" 123do echo 循环体3：$&#123;x&#125;done 8. while循环1234567891011121314151617181920212223242526272829303132333435语法:while 条件语句do 循环体done# 遍历字符串str1=\"helloWorld!\"index=0len=$&#123;#str1&#125;while [ $index -lt $len ]do echo $&#123;str1:$&#123;index&#125;:1&#125; index=`expr $&#123;index&#125; + 1`done# 计算1+2+3+...+100num=1sum=0while [ $&#123;num&#125; -le 100 ]do sum=`expr $&#123;sum&#125; + $&#123;num&#125;` num=`expr $&#123;num&#125; + 1`doneecho 1+2+3+...+100 = $&#123;sum&#125;# 死循环while truedo read -p \"请输入一个数字:\" num if [ $&#123;num&#125; == 100 ] then break fidone 9.函数1）函数的声明和调用123456789101112131415161718192021222324252627282930313233343536# 1.函数的声明声明的语法：函数名()&#123; 函数体&#125;调用函数语法: 函数名#声明函数func1()&#123; echo 你好函数1&#125;#调用函数func1# 2.有参数的函数# 声明的时候不需要形参, 直接在函数体中通过'$&#123;N&#125;'来获取第N个实参# 调用的时候: 函数名 实参1 实参2 实参3 ...func2()&#123; echo 函数2被调用 echo 第一个参数: $&#123;1&#125; echo 第二个参数: $&#123;2&#125; echo 第三个参数: $&#123;3&#125; &#125;func2 10 20 \"abc\"# 3.函数的返回值# return 数字 - 数字的范围是0~255func3()&#123; echo 函数3被调用 return 256 #a=`expr 100 + 200`&#125;func3echo $&#123;?&#125;","tags":[]},{"title":"Linux定时任务","date":"2019-12-20T10:32:03.065Z","path":"2019/12/20/Linux定时任务/","text":"Linux定时任务通过制定 ```crontab -e``编辑和开启定时任务 1234567891011121314151617181920212223242526# 创建一个完整的定时任务，需要确定时间和任务# 1.时间 .---------------- minute (0 - 59) # 分 | .------------- hour (0 - 23) # 时 | | .---------- day of month (1 - 31) # 日 | | | .------- month (1 - 12) OR jan,feb,mar,apr ... # 月 | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat | | | | | * * * * * user-name command to be executed * * * * * - 每分钟执行一次任务(每隔一分钟) */1 * * * * - 每分钟执行一次任务(每隔一分钟) */2 * * * * - 每2分钟执行一次任务(每隔2分钟) * */1 * * * - 每隔1小时 * * */1 * * - 每隔1天 * * * */2 * - 每隔两个月 * * * * fri - 每周五执行任务 30 * * * * - 时间点到30分的时候做 0 * * * * - 时间点到整点的时候执行任务 30 2 * * * - 时间到 02:30 的时候执行任务 0 12 28 * * - 每月28号12:00执行任务 # 2.任务写Linux指令, 指令如果有结果，结果看不到","tags":[]},{"title":"git常用指令","date":"2019-12-20T10:32:03.034Z","path":"2019/12/20/git常用指令/","text":"git常用指令1.基本指令git init &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; —— 新建git仓库git add 文件/文件夹 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; —— 将文件添加到缓存区中git add -A &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; — 添加所有内容到缓存区中git status &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;——— 查看git状态git commit -m ‘提交信息’ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;—— 将缓存区中的内容全部提交到git本地仓库中 git log &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;——- 查看提交日志 git reset -- hard HEAD &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;—— 让工作目录中的内容和仓库中的内容保持一致 git tag v0.1 —— 设置版本号 git reset --hard HEAD^ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;—— 回到上一个版本 (–hard保持仓库,暂存区,工作区一致)git reset --hard 版本号 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;—— 回到指定的版本 git reflog —— 查询所有版本 git checkout 文件名 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; —— 从暂存区中恢复工作目录中的内容(让工作区中的指定文件，回到上次提交的时候的状态) git clone &lt;url&gt; - 将服务器上的项目(仓库)克隆 (使用https地址需要输入密码，使用ssh地址需要添加公钥) git clone --depth=1 git@gitee.com:wang_ba_tian/djangocase.git djangcase2 不获取历史版本,只获取当前版本并重命名为djangocase2 ​ git remote remove origin 移除当前仓库 ​ git revert -e b8aa 修改内容 git remote add origin 地址 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;—– 关联远程仓库(只需要关联一次) git push [-u] origin master &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;—– 提交(-u在第一次提交分支的时候才用) git push — 将本地仓库的内容提交到远程仓库master分支上 git push origin 分支名 — 将本地仓库的内容提交到远程仓库对应的分支上, 如果分支不存在会自动创建 git pull — 将远程仓库中的内容更新到本地仓库和工作区中 2.分之管理创建仓库会默认给我们创建一个master分之,这个分之一般作为提交和发布分之;开发一般会自己创建一个develop分之，用来开发和测试;多人协作的时候还可能根据不同的人或者(不同的功能)创建不同的分之，用来独立开发 常见分之： master(主要是合并develop), develop(主要合并下面的其他分支), 功能/人员分之(开发) git branch [-a] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - 查看分之git branch 分之名 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- 创建分之git checkout 分支名 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- 切换分之git checkout -b 分之名 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - 切换并创建新的分之git diff 分之1 分之2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- 查看两个分之之间的差异git merge 分之名 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- 让当前分之和指定分之进行合并 注意: 切换分之、push、pull，这些操作前要保证工作区是clean 怎么避免冲突： 不要发生多个分之对同一个文件在同一个版本下进行修改(和同伴确认和商量)","tags":[]},{"title":"Linux日常指令","date":"2019-12-20T10:32:02.956Z","path":"2019/12/20/Linux日常指令/","text":"a1.日常指令1.cd指令 - 进入文件夹cd 文件夹路径(路径可以是绝对地址也可以是相对地址) - 进入到指定路径对应的文件夹 cd .. - 返回上层目录 cd / - 进入操作系统根目录 cd ~ - 进入电脑的文件系统根目录 2.ls指令 - 显示当前目录中的内容ls - 直接显示当前文件夹中的内容的名字(隐藏文件和文件夹看不到) ls -l/-lh - 显示当前文件夹中的内容和内容的基本信息(隐藏文件和文件夹看不到) ls -a - 显示当前文件夹中所有的内容(包括隐藏文件) ls -R - 递归显示当前目录以及当前目录下所有的子目录中的内容 ls -r - 内容倒序显示 ls -S/-t - 显示文件夹中的内容，并且内容按大小/时间从大到小排序 12ls -Sr - 按大小从小到大排序ls -Srlh - 按大小从小到大排序,并且显示内容的基本信息 3. pwd指令pwd - 查看当前目录的绝对路径(系统目录下的) 4.文件操作1）touch指令 - 新建文件 touch 文件路径 - 在指定位置创建指定文件 123touch a.txt - 在当前目录下新建一个文件a.txttouch ../a.txt - 在当前目录的上层目录新建一个文件a.txttouch /home/a/a.txt - 在根目录下home目录中的a目录里面创建一个文件a.txt 2) cat指令 - 查看文件内容(读文件) cat 文件路径 - 读取指定路径对应的文件的内容 3) vim指令 vim 文件路径 - 使用vim打开文件 #####5.文件夹操作 1) mkdir指令 - 新建文件夹 mkdir 文件夹路径 - 在指定位置创建文件夹 mkdir -p 文件夹路径 - 在指定位置创建文件夹(会创建目录中所有不存在的文件夹) 12mkdir -p a/b/c - a,b,c可以都没有，会在当前目录中创建a,在a中创建b，b中创建cmkdir -p a/&#123;b,c&#125; - a,b,c可以都没有，会在当前目录中创建a,在a中创建b和c 6.删除文件和文件夹1)rm指令 - 删除文件和文件夹 rm 文件路径 - 删除指定文件(删除的时候会循环是否确定删除，y-同意， n-不同意) rm -f 文件路径 - 删除指定文件（删除的时候不询问） rm -r 文件夹路径 - 删除指定文件夹 2) rmdir指令 - 删除空目录 rmdir 文件夹路径 - 删除指定文件夹(这个文件夹必须是空的) 3)cp指令 - 拷贝 cp 文件路径1 文件路径2 - 将文件路径1指定的文件中的内容复制到文件路径2指定的文件中(文件路径2对应的 文件本身是不存在) ​ - 将文件1中的内容复制粘贴到文件2(如果文件2不存，会自动创建；如果存在会询问 是否覆盖) cp 文件路径 文件夹路径 - 将指定文件复制粘贴到指定文件夹中 cp -r 文件夹路径1 文件夹路径2 - 将文件夹1复制粘贴到文件夹2中 4)mv指令 - 移动 mv 文件路径1 文件路径2 - 将文件1移动文件2所在的位置 123mv 文件名1 文件名2 - 对文件进行重命名(将文件名1修改为文件名2)mv a.txt b.txt - 将当前文件夹中的a.txt重命名为b.txtmv /home/a.txt /home/b.txt - 将系统根目录下home文件中的a.txt重命名为b.txt mv 文件路径 文件夹路径 - 将文件直接移动到指定文件夹中 mv 文件夹路径1 文件夹路径2 - 将文件夹1移动到文件夹2中 7.history指令 - 获取历史记录(指令的历史记录)history - 显示当前系统已经执行过的所有的指令 1234#如果想要显示历史记录的时候显示指令执行的时间需要修改~/.bashrc文件:export HISTTIMEFORMAT=\"[%y‐%m‐%d_%T] \" # 修改完成后需要通过指令: source ~/.bashrc 去执行这个配置文件， 最后历史记录的时间才会生效 8. 创建连接1)创建软连接（掌握!）ln -s 源文件路径 软连接文件地址 - 给源文件在指定位置创建一个软连接(软连接本质就是用来保存源文件绝对 地址的一个文件， 可以理解为windows中的快捷方式) ​ 注意: 源文件路径必须写绝对路径 ​ 如果删除或者移动源文件，软连接会直接无效 2)创建硬链接ln 源文件路径 硬连接文件地址 - 给源文件在指定位置创建一个硬链接 ​ 硬链接的本质就是源文件内容的另外一个引用，所以删除或者移动源文件硬 链接仍然有效，只是删除硬链接会变成普通文件 9.进程相关指令1) ps指令ps - 查看进程状态 ps -aux - 查看当前所有的进程的信息 ps grep 进程名/进程ID - 根据进程名/进程ID查看指定进程 2)top指令top - 实时查看当前所有的进程信息和系统信息 top -p PID1,PID2,…. - 实时监测指定的进程 3)free指令free - 显示当前系统的内存信息，显示的时候以kb为单位 free -单位 - 显示当前系统的内存信息，以指定单位来显示 1free -m - 显示当前系统的内存信息，以Mb为单位 4)kill指令kill 进程ID - 杀掉指定id对应的进程 kill -1/-9/-15 进程ID - 以指定的方式(-1表示不间断重启; -9表示强制杀死进程；-15表示正常结束进程)杀掉指定 进程 pkill 进程名 - 杀死指定进程名对应的进程(中间可以加-1/-9/-15) killall 进程名 - 杀死和进程名相关的所有进程 5)uptimeuptime - 获取系统信息 10.用户管理一个Linux操作系统可以有多个用户(user)，也可以有多个用户组(group); 用户和用户组之间的关系是多对多 users - 查看当前用户 groups - 查看当前分组 groupadd 分组名 - 创建分组(管理员才能创建; 可以通过查看/etc/group文件来查看当前系统所有的分组) useradd 用户名 - 创建指定用户(1.用户创建成功后系统会自动在/home目录下创建一个和用户名同名的文件 夹；2.会自动创建和用户名同名的分组，并且将当前用户添加到这个分组中) useradd -G 分组1,分组2,… 用户名 - 创建指定用户，并且将用户添加到指定分组中 usermod -G 分组1,分组2 用户名 - 修改用户分组 password 用户名 - 修改用户密码(需要root权限) su 用户名 - 切换账号(root登录的时候切换不需要密码，其他账号需要) exit - 退出当前账号 sudo - 在命令前sudo是以管理员身份执行指令 注意: 不是所有的用户都可以通过sudo来以管理员身份执行指令，如果想要能够使用sudo必须添加配置 ​ a.ubuntu: 将需要有管理员身份的账号添加到sudo分组中 ​ b.redhat和contos: 在/etc/sudoers配置文件中添加代码： 123## Allow root to run any commands anywhereroot ALL=(ALL) ALL #(默认有的)xiaoming ALL=(ALL) ALL #(自己添加的，xiaoming是用户名) 11.文件权限默认情况下文件和文件夹的权限: 文件所有者有读写权限， 同组用户和其他用户都是只读权限。 1）chmod指令chmod 权限值 文件路径 - 将指定文件的权限修改成指定值 12345678权限： rwx r-- rw-权限二进制：111 100 110 权限值: 7 4 6chmod 746 文件路径权限: rwx rwx rwx权限值: 7 7 7chmod 777 文件路径 chmod [a,u,g,o]/[+-]/[r,w,x] 文件地址 - 给指定文件对应指定用户添加或者删除指定权限 ​ (a-所有用户，u-文件所有者,g-同组用户,o-其他用户； ​ +表示添加权限， -表示删除权限; ​ r-表示读权限, w表示写权限,x表示执行权限) 12chmod a-x 文件地址 # 删除所有用户的执行权限chmod u+w 文件地址 # 给文件所有者添加写的权限 12.日志管理1)显示文件内容a.cat指令 - 直接显示文件中所有的内容 cat 文件 - 直接查看文件所有内容 总结: 查看文件内容的时候可以加参数-n，让内容在显示的时候显示行号 b.查看部分内容 head N 文件地址 - 显示指定文件前N行内容(-n参数无效) tail N 文件地址 - 显示指定文件最后N行内容(-n参数无效) c.分页显示 less 文件 - 按页显示文件内容(通过快捷键控制内容显示过程； 文件内容不会打印到shell/终端里) less -N 文件 - 按页显示文件内容，每次翻页的时候翻N行 more 文件 - 按页显示文件内容(通过快捷键控制内容显示过程； 文件内容会打印到shell/终端里) more -N 文件 - 按页显示文件内容，每次翻页的时候翻N行 123456789101112131415快捷键:- 按 j 向下一行- 按 k 向上一行- 按 f 向下翻一页- 按b 向上翻一页- 按 g 到全文开头- 按 G 到全文结尾- 按 Q 退出 2)结果的处理凡是有的打印结果的指令，我们都可以通过相关指令对应结果进行处理 a. 管道 - |如果需要对某一个指令的结果使用另外的指令进行二次处理的时候，就需要用到管道(|) b.sort - 排序sort - 从小到大排序(将一行内容作为一个字符串，按字符串大小对应内容进行排序，默认不区分大小写) 1234567891011cat a.txt |sort # 对a.txt的文件内容从小到大排序显示sort的参数:-r - 逆序-nk 1 - 数值大小排序-nk 2 - 字符大小排序(默认)cat a.txt|sort -nk 1 # 对a.txt的文件内容按数字大小从小到大排序cat a.txt|sort -rnk 1 # 对a.txt的文件内容按数字大小从大到小排序cat a.txt|sort -nk 2 # 对a.txt的文件内容按字符大小从小到大排序(默认)cat a.txt|sort -rnk 2 # 对a.txt的文件内容按字符大小从大到小排序 c.uniq -去重uniq - 只能将紧挨着的相同行去掉重复的(如果需要去掉所有重复的行，先排序将相同的行放到一起) 12345cat a.txt|uniq # 去掉a.txt文件内容中相邻重复的行cat a.txt|sort|uniq # 去掉a.txt文件内容中所有重复的行uniq的参数-c - 重复次数 d.awk - 获取列awk ‘{print $N}’ - 获取内容中第N列的数据 12history|awk '&#123;print $2&#125;' # 获取历史记录第2列的内容history|awk '&#123;print $2,$3&#125;' # 获取历史记录第2列和第3列的内容 练习: 1history |awk '&#123;print $4&#125;' |sort |uniq ‐c | sort ‐rnk 1 | head ‐n 3 # 统计最常用的3个指令及其使用次数 3）输出重定向 - &gt;/&gt;&gt;执行有打印结果的指令 &gt; 文件地址 - 将指定指令执行的结果保存到指定文件中(先清除原文件内容再添加) 执行有打印结果的指令 &gt;&gt; 文件地址 - 将指定指令执行的结果保存到指定文件中(直接将结果追加到原文件中) 1234history &gt; a.txt #将当前历史记录直接保存到a.txt文件中# 将最常用的3个指令及其使用次数保存到a.txt文件中history |awk '&#123;print $4&#125;' |sort |uniq ‐c | sort ‐rnk 1 | head ‐n 3 &gt; a.txt 4)统计wc -c/-w/-l 文件地址 - 统计指定文件中字符/单词/行的数量 5)查找grep - 找内容a. grep 内容 文件地址 - 在指定文件中查找指定内容(返回文件中所有包含指定内容的行) 12345678910grep you a.txt # 获取a.txt中包含you的所有的行grep的参数:-n - 显示结果的时候显示行号-i - 查找内容的时候忽略大小写-E - 按正则表达式进行匹配 使用方法： grep -E '正则表达式' 文件 注意: Linux操作系统中正则表达式不支持:\\d,\\D,\\w,\\W,\\s,\\S,\\b,\\B; 其他语法都支持-v - 忽略字段 grep you a.txt -v # 获取a.txt中不包含you的所有的行 b. 执行有打印结果的指令 |grep 内容 - 在指令执行结果中查找指定内容 c. grep -r 内容 文件夹地址 -在指定文件夹中所有的文件中查找指定内容 find - 找文件find 文件夹路径 -name 文件名 - 在指定文件夹下按文件名找指定文件 123456# 找指定文件名find dir1 -name 'test1.py' # 在文件夹dir1找名字是test1.py的文件find dir1 -name '*.txt' # 在文件夹dir1找后缀是txt的所有文件find dir1 -name 'test*.txt'find dir1 -name 'test*'find dir1 -name '*c.txt' find 文件夹路径 -size +/-文件大小 - 在指定文件夹下找文件大小满足条件的所有的文件 1234find dir1 -size +4k # 查找在文件夹dir1中所有大于4k的文件find dir1 -size -4k # 查找在文件夹dir1中所有小于4k的文件find dir1 -size +5k -size -10k # 查找在文件夹dir1中所有大于5k并且小于10k的文件(文件大小如果是小数，算的时候向上取整)find dir1 -size +4k -name '*.txt' # 查找在文件夹dir1中所有大于4k的txt文件 查指令which 指令名 -精确查找当前指令对应的文件的路径 whereis 指令名 -查找和指定指令相关的所有的文件的路径 man 指令名 -获取指定指令的使用手册 指令名 — help -获取指定指令的帮助文档","tags":[]},{"title":"vim的使用","date":"2019-12-20T10:32:02.925Z","path":"2019/12/20/vim的使用/","text":"vim的使用1.vim的三种模式命令模式：末尾既没有插入的字样也没有冒号 ​ (在编辑模式和末行模式下按esc键可以进入命令模式) 编辑模式：末尾会显示’—插入—‘/‘—insert—‘， 并且在编辑模式下可以对文件进行输入操作(可以编辑) ​ (在命令模式下按i就可以进入编辑模式) 末行模式：末尾显示冒号，并且冒号后边可以输入内容 ​ (在命令模式下输入冒号就可以进入末行模式) 2.vim的配置通过编辑~/.vimrc文件或者/etc/vimrc文件可以对vim编辑器进行相关配置 3.基本操作1）保存和退出所有保存和退出的指令都是末行模式下执行的 w - 只保存(相当于ctr+s) q - 直接退出(只有当前文件的内容全部保存才能直接退出，如果不保存强制退出，需要在q加!) wq - 先保存再退出 注意: 强制执行在指令后加! 2)光标操作所有光标操作对应的指令都是在命令模式下执行的 ^ - 直接将光标移动到行首 $ - 直接将光标移动到行尾 G - 移动到文件末尾 gg - 移动到文件开头 行号G - 移动到指定行号的位置 3)文本操作以下指令前面如果没有冒号表示在命令模式下执行，有冒号的在末行模式下执行 dd - 删除当前光标所在的行 数字dd - 数字如果是N， 从光标所在的位置开始删N行 ：%d - 末行模式下输入%d，删除所有 u - 撤销 ctr+r - 反撤销 yy - 复制光标所在的行 数字yy - 数字如果是N， 从光标所在的位置开始复制N行 : %y - 末行模式下输入%y, 复制所有 p - 粘贴 4)查找：/正则表达式 - 查找当前文件中符合正则表达式的内容(结果可以用n和N来切换) 123456vim中正则表达式的要求:1)python正则中所有的语法都有效2)单独使用有特殊功能的符号，在使用的时候需要加\\才有效r'\\d+' -&gt; /\\d\\+r'\\d&#123;3&#125;' -&gt; /\\d\\&#123;3&#125;r'and|or' -&gt; /and\\|or ：1,$s/被替换的对象对应的正则/替换内容/参数 - 将文件中正则匹配到的内容替换成指定内容 12345参数:g - 全局匹配(会替换所有符合要求的字符串，默认情况下一行只替换一个)i - 匹配的时候忽略大小写c - 替换的时候给出提示e - 忽略错误(忽略正则的错误) 4.高级操作1)比较文件vim -d 文件路径1 文件路径2 2)同时打开和编辑多个文件vim 文件路径1 文件路径2 … 123456#1.切换窗口内容在末行模式下输入: ls 可以查看当前打开的所有的文件和文件对象的标号在末行模式下输入: b标号 可以将当前窗口中的内容切换到指定标号对应的文件的内容#2.窗口的拆分在末行模式下输入: sp/vs 可以将当前窗口垂直方向/水平方向进行拆分；拆分后可以在命令模式下按ctr+w来切换窗口","tags":[]}]